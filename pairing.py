

# This file was *autogenerated* from the file pairing.sage
from sage.all_cmdline import *   # import sage library

_sage_const_21888242871839275222246405745257275088696311157297823662689037894645226208583 = Integer(21888242871839275222246405745257275088696311157297823662689037894645226208583); _sage_const_12 = Integer(12); _sage_const_4965661367192848881 = Integer(4965661367192848881); _sage_const_21888242871839275222246405745257275088548364400416034343698204186575808495617 = Integer(21888242871839275222246405745257275088548364400416034343698204186575808495617); _sage_const_1 = Integer(1); _sage_const_36 = Integer(36); _sage_const_4 = Integer(4); _sage_const_3 = Integer(3); _sage_const_24 = Integer(24); _sage_const_2 = Integer(2); _sage_const_6 = Integer(6); _sage_const_18 = Integer(18); _sage_const_9 = Integer(9); _sage_const_0 = Integer(0); _sage_const_10857046999023057135944570762232829481370756359578518086990519993285655852781 = Integer(10857046999023057135944570762232829481370756359578518086990519993285655852781); _sage_const_11559732032986387107991004021392285783925812861821192530917403151452391805634 = Integer(11559732032986387107991004021392285783925812861821192530917403151452391805634); _sage_const_8495653923123431417604973247489272438418190587263600148770280649306958101930 = Integer(8495653923123431417604973247489272438418190587263600148770280649306958101930); _sage_const_4082367875863433681332203403145435568316851327593401208105741076214120093531 = Integer(4082367875863433681332203403145435568316851327593401208105741076214120093531); _sage_const_64 = Integer(64); _sage_const_128 = Integer(128); _sage_const_192 = Integer(192); _sage_const_256 = Integer(256); _sage_const_0xb5773b104563ab30 = Integer(0xb5773b104563ab30); _sage_const_0x347f91c8a9aa6454 = Integer(0x347f91c8a9aa6454); _sage_const_0x7a007127242e0991 = Integer(0x7a007127242e0991); _sage_const_0x1956bcd8118214ec = Integer(0x1956bcd8118214ec); _sage_const_0x6e849f1ea0aa4757 = Integer(0x6e849f1ea0aa4757); _sage_const_0xaa1c7b6d89f89141 = Integer(0xaa1c7b6d89f89141); _sage_const_0xb6e713cdfae0ca3a = Integer(0xb6e713cdfae0ca3a); _sage_const_0x26694fbb4e82ebc3 = Integer(0x26694fbb4e82ebc3); _sage_const_0xe4bbdd0c2936b629 = Integer(0xe4bbdd0c2936b629); _sage_const_0xbb30f162e133bacb = Integer(0xbb30f162e133bacb); _sage_const_0x31a9d1b6f9645366 = Integer(0x31a9d1b6f9645366); _sage_const_0x253570bea500f8dd = Integer(0x253570bea500f8dd); _sage_const_0xa1d77ce45ffe77c7 = Integer(0xa1d77ce45ffe77c7); _sage_const_0x07affd117826d1db = Integer(0x07affd117826d1db); _sage_const_0x6d16bd27bb7edc6b = Integer(0x6d16bd27bb7edc6b); _sage_const_0x2c87200285defecc = Integer(0x2c87200285defecc); _sage_const_0x3350c88e13e80b9c = Integer(0x3350c88e13e80b9c); _sage_const_0x7dce557cdb5e56b9 = Integer(0x7dce557cdb5e56b9); _sage_const_0x6001b4b8b615564a = Integer(0x6001b4b8b615564a); _sage_const_0x2682e617020217e0 = Integer(0x2682e617020217e0); _sage_const_0x0 = Integer(0x0); _sage_const_8 = Integer(8)
import json

# --- Below we specify the parameters of the curve --- #

# Defining the base prime field
q = Integer(_sage_const_21888242871839275222246405745257275088696311157297823662689037894645226208583 ) # EC group order
Fq = GF(q) 

# r is taken from https://hackmd.io/@jpw/bn254
k = Integer(_sage_const_12 ) # Embedding degree
t = Integer(_sage_const_4965661367192848881 )
r = Integer(_sage_const_21888242871839275222246405745257275088548364400416034343698204186575808495617 )
e = (q**(_sage_const_12 )-_sage_const_1 )/r

# Defining elliptic curve field parameters
Fr = GF(r)

# Making sure parameters are correctly defined
# See https://eprint.iacr.org/2010/354.pdf, Equation 1 for details.
assert q == _sage_const_36 *t**_sage_const_4  + _sage_const_36 *t**_sage_const_3  + _sage_const_24 *t**_sage_const_2  + _sage_const_6 *t + _sage_const_1 
assert r == _sage_const_36 *t**_sage_const_4  + _sage_const_36 *t**_sage_const_3  + _sage_const_18 *t**_sage_const_2  + _sage_const_6 *t + _sage_const_1 

# Defining the extensions
# Fq2...
K2 = PolynomialRing(Fq, names=('x',)); (x,) = K2._first_ngens(1)
Fq2 = Fq.extension(x**_sage_const_2 +_sage_const_1 , names=('u',)); (u,) = Fq2._first_ngens(1)

# Fq6...
K6 = PolynomialRing(Fq2, names=('y',)); (y,) = K6._first_ngens(1)
Fq6 = Fq2.extension(y**_sage_const_3  - (u+_sage_const_9 ), names=('v',)); (v,) = Fq6._first_ngens(1)

# Defining the Fq12 is a bit more tricky...
p = Fq.characteristic()
Fq12 = GF(p**_sage_const_12 , names=('G',)); (G,) = Fq12._first_ngens(1)

i = sqrt(Fq12(-_sage_const_1 ))
R12 = PolynomialRing(Fq12, names=('Y',)); (Y,) = R12._first_ngens(1)

j = (Y**_sage_const_3  - (i+_sage_const_9 )).roots(multiplicities=False)[_sage_const_0 ]
w = sqrt(j)

P = w.minpoly()
Fq12 = GF(p**_sage_const_12 , modulus=P, names=('W',)); (W,) = Fq12._first_ngens(1)

def c0c3c4_to_fq12(c0: Fq2, c3: Fq2, c4: Fq2) -> Fq12:
    return c0[_sage_const_0 ] + c0[_sage_const_1 ]*(W**_sage_const_6 -_sage_const_9 ) + (c3[_sage_const_0 ]+c3[_sage_const_1 ]*(W**_sage_const_6 -_sage_const_9 ))*W + (c4[_sage_const_0 ]+c4[_sage_const_1 ]*(W**_sage_const_6 -_sage_const_9 ))*W**_sage_const_3 

# Defining the G1 Curve and its generator
G1 = EllipticCurve(Fq, [_sage_const_0 , _sage_const_3 ])
G1_GEN = G1(_sage_const_1 , _sage_const_2 )

# Defining the G2 Curve
b = _sage_const_3  / (u + _sage_const_9 )
G2 = EllipticCurve(Fq2, [_sage_const_0 , b])
G2_GEN = G2(_sage_const_10857046999023057135944570762232829481370756359578518086990519993285655852781 +
            _sage_const_11559732032986387107991004021392285783925812861821192530917403151452391805634 *u,
            _sage_const_8495653923123431417604973247489272438418190587263600148770280649306958101930 +
            _sage_const_4082367875863433681332203403145435568316851327593401208105741076214120093531 *u)

# Converts a tuple (X : Y : Z) from Fq2^3 to a point in G2 
# using Jacobian coordinates
def tuple_to_g2(t: tuple[Fq2, Fq2, Fq2]) -> G2:
    return G2(t[_sage_const_0 ]/t[_sage_const_2 ]**_sage_const_2 , t[_sage_const_1 ]/t[_sage_const_2 ]**_sage_const_3 )

# Helper debugging functions
g1_point_to_dictionary = lambda point : {
    'x': str(point[_sage_const_0 ]),
    'y': str(point[_sage_const_1 ])
}
g2_point_to_dictionary = lambda point : {
    'x': {
        'c0': str(point[_sage_const_0 ][_sage_const_0 ]), 
        'c1': str(point[_sage_const_0 ][_sage_const_1 ])
    }, 
    'y': {
        'c0': str(point[_sage_const_1 ][_sage_const_0 ]), 
        'c1': str(point[_sage_const_1 ][_sage_const_1 ])
    }
}

# Some coefficients for easier life
SIX_U_PLUS_TWO_WNAF = [
    _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_1 , _sage_const_0 , _sage_const_1 , _sage_const_0 , -_sage_const_1 , 
    _sage_const_0 , _sage_const_0 , _sage_const_1 , -_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_1 , _sage_const_0 , 
    _sage_const_0 , _sage_const_1 , _sage_const_1 , _sage_const_0 , -_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_1 , 
    _sage_const_0 , -_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_1 , _sage_const_1 , 
    _sage_const_1 , _sage_const_0 , _sage_const_0 , -_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_1 , _sage_const_0 , 
    _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 , -_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_1 , 
    _sage_const_1 , _sage_const_0 , _sage_const_0 , -_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_1 , 
    _sage_const_1 , _sage_const_0 , -_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_1 , _sage_const_0 , _sage_const_1 , _sage_const_1 
]

# Converts the Montomery form represented by 4 64-bit limbs to an integer in Fq
def from_libms(limbs):
    montomery = limbs[_sage_const_0 ] | (limbs[_sage_const_1 ] << _sage_const_64 ) | (limbs[_sage_const_2 ] << _sage_const_128 ) | (limbs[_sage_const_3 ] << _sage_const_192 )
    return Fq(montomery) * Fq(_sage_const_2 **(-_sage_const_256 ))

# This is for the last step of Miller loop
FROBENIUS_COEFF_FQ6_C1_1 = from_libms([
    _sage_const_0xb5773b104563ab30 ,
    _sage_const_0x347f91c8a9aa6454 ,
    _sage_const_0x7a007127242e0991 ,
    _sage_const_0x1956bcd8118214ec ,
]) + from_libms([
    _sage_const_0x6e849f1ea0aa4757 , 
    _sage_const_0xaa1c7b6d89f89141 , 
    _sage_const_0xb6e713cdfae0ca3a , 
    _sage_const_0x26694fbb4e82ebc3 ,
])*u
assert FROBENIUS_COEFF_FQ6_C1_1 == (_sage_const_9 +u)**((q-_sage_const_1 )/_sage_const_3 ), 'FROBENIUS_COEFF_FQ6_C1_1 is not correct!'

# (9+u)**((q-1)/2)
XI_TO_Q_MINUS_1_OVER_2 = from_libms([
    _sage_const_0xe4bbdd0c2936b629 , 
    _sage_const_0xbb30f162e133bacb , 
    _sage_const_0x31a9d1b6f9645366 , 
    _sage_const_0x253570bea500f8dd ,
]) + from_libms([
    _sage_const_0xa1d77ce45ffe77c7 , 
    _sage_const_0x07affd117826d1db , 
    _sage_const_0x6d16bd27bb7edc6b , 
    _sage_const_0x2c87200285defecc ,
])*u
assert XI_TO_Q_MINUS_1_OVER_2 == (_sage_const_9 +u)**((q-_sage_const_1 )/_sage_const_2 ), 'Non-XI_TO_Q_MINUS_1_OVER_2 is not correct!'

# (9+u)**((q^2-1)/3)
FROBENIUS_COEFF_FQ6_C1_2 = from_libms([
    _sage_const_0x3350c88e13e80b9c ,
    _sage_const_0x7dce557cdb5e56b9 ,
    _sage_const_0x6001b4b8b615564a ,
    _sage_const_0x2682e617020217e0 ,
]) + from_libms([
    _sage_const_0x0 , 
    _sage_const_0x0 , 
    _sage_const_0x0 , 
    _sage_const_0x0 ,
])*u
assert FROBENIUS_COEFF_FQ6_C1_2 == (_sage_const_9 +u)**((q**_sage_const_2 -_sage_const_1 )/_sage_const_3 ), 'FROBENIUS_COEFF_FQ6_C1_2 is not correct!'

# --- Line functions tested ---
# Original implementation from https://eprint.iacr.org/2010/354.pdf

def doubling_step(Q: G2, P: G2):
    X_Q, Y_Q, Z_Q = copy(Q[_sage_const_0 ]), copy(Q[_sage_const_1 ]), copy(Q[_sage_const_2 ])
    x_P, y_P = copy(P[_sage_const_0 ]), copy(P[_sage_const_1 ])

    tmp0 = X_Q**_sage_const_2 
    tmp1 = Y_Q**_sage_const_2 
    tmp2 = tmp1**_sage_const_2 
    tmp3 = (tmp1 + X_Q)**_sage_const_2  - tmp0 - tmp2
    tmp3 = _sage_const_2 *tmp3
    tmp4 = _sage_const_3 *tmp0
    tmp6 = X_Q + tmp4
    tmp5 = tmp4**_sage_const_2 
    X_T = tmp5 - _sage_const_2 *tmp3
    Z_T = (Y_Q + Z_Q)**_sage_const_2  - tmp1 - Z_Q**_sage_const_2 
    Y_T = (tmp3 - X_T) * tmp4 - _sage_const_8 *tmp2
    tmp3 = -_sage_const_2 *tmp4*Z_Q**_sage_const_2 
    tmp3 = tmp3*x_P
    tmp6 = tmp6**_sage_const_2  - tmp0 - tmp5 - _sage_const_4 *tmp1
    tmp0 = _sage_const_2 *Z_T*Z_Q**_sage_const_2 
    tmp0 = tmp0 * y_P

    return (tmp0, tmp3, tmp6), (X_T, Y_T, Z_T)

def addition_step(Q: G2, R: G2, P: G1):
    X_Q, Y_Q, Z_Q = copy(Q[_sage_const_0 ]), copy(Q[_sage_const_1 ]), copy(Q[_sage_const_2 ])
    X_R, Y_R, Z_R = copy(R[_sage_const_0 ]), copy(R[_sage_const_1 ]), copy(R[_sage_const_2 ])
    x_P, y_P = copy(P[_sage_const_0 ]), copy(P[_sage_const_1 ])

    t0 = X_Q * Z_R**_sage_const_2 
    t1 = (Y_Q + Z_R)**_sage_const_2  - Y_Q**_sage_const_2  - Z_R**_sage_const_2 
    t1 = t1 * Z_R**_sage_const_2 
    t2 = t0 - X_R
    t3 = t2**_sage_const_2  
    t4 = _sage_const_4 *t3
    t5 = t4 * t2
    t6 = t1 - _sage_const_2 *Y_R
    t9 = t6 * X_Q
    t7 = X_R*t4
    X_T = t6**_sage_const_2  - t5 - _sage_const_2 *t7
    Z_T = (Z_R + t2)**_sage_const_2  - Z_R**_sage_const_2  - t3
    t10 = Y_Q + Z_T
    t8 = (t7 - X_T)*t6
    t0 = _sage_const_2 *Y_R*t5
    Y_T = t8 - t0
    t10 = t10**_sage_const_2  - Y_Q**_sage_const_2  - Z_T**_sage_const_2 
    t9 = _sage_const_2 *t9 - t10
    t10 = _sage_const_2 *Z_T*y_P
    t6 = -t6
    t1 = _sage_const_2 *t6*x_P

    return (t10, t1, t9), (X_T, Y_T, Z_T)

def miller_loop(P: G1, Q: G2):
    # --- Gathering coefficients step ---
    T = copy(Q)
    Q_negative = -copy(Q)
    f = Fq12.one()
    for i in reversed(range(_sage_const_1 , len(SIX_U_PLUS_TWO_WNAF))):
        if i != len(SIX_U_PLUS_TWO_WNAF) - _sage_const_1 :
            f = f*f

        (c0, c3, c4), T2 = doubling_step(T, P)
        assert tuple_to_g2(T2) == _sage_const_2 *tuple_to_g2(T), 'Doubling step is wrong!'
        f = f * c0c3c4_to_fq12(c0, c3, c4)
        T = T2

        x = SIX_U_PLUS_TWO_WNAF[i-_sage_const_1 ]
        if x == _sage_const_1 :
            (c0, c3, c4), TQ = addition_step(Q, T, P)
            assert tuple_to_g2(TQ) == tuple_to_g2(T) + tuple_to_g2(Q), 'Addition step is wrong!'
            f = f * c0c3c4_to_fq12(c0, c3, c4)
            T = TQ
        elif x == -_sage_const_1 :
            (c0, c3, c4), TQ = addition_step(Q_negative, T, P)
            assert tuple_to_g2(TQ) == tuple_to_g2(T) + Q_negative, 'Addition step is wrong!'
            f = f * c0c3c4_to_fq12(c0, c3, c4)
            T = TQ

    # Some additional steps to finalize the Miller loop...
    # Q1 <- pi_p(Q)
    Q1 = [Q[_sage_const_0 ], Q[_sage_const_1 ], Q[_sage_const_2 ]]
    Q1[_sage_const_0 ] = Q1[_sage_const_0 ].conjugate() * FROBENIUS_COEFF_FQ6_C1_1
    Q1[_sage_const_1 ] = Q1[_sage_const_1 ].conjugate() * XI_TO_Q_MINUS_1_OVER_2

    # Q2 <- -pi_{p^2}(Q)
    Q2 = [Q[_sage_const_0 ], Q[_sage_const_1 ], Q[_sage_const_2 ]]
    Q2[_sage_const_0 ] = Q2[_sage_const_0 ] * FROBENIUS_COEFF_FQ6_C1_2

    # Line evaluation at Q1
    (c0, c3, c4), TQ1 = addition_step(Q1, T, P)
    assert tuple_to_g2(TQ1) == tuple_to_g2(T) + tuple_to_g2(Q1), 'Addition step is wrong!'
    f = f * c0c3c4_to_fq12(c0, c3, c4)
    T = TQ1

    # Line evaluation at Q2
    (c0, c3, c4), TQ2 = addition_step(Q2, T, P)
    assert tuple_to_g2(TQ2) == tuple_to_g2(T) + tuple_to_g2(Q2), 'Addition step is wrong!'
    f = f * c0c3c4_to_fq12(c0, c3, c4)
    
    return f

def pairing(P, Q):
    f = miller_loop(P, Q)
    return f**e # This part is actually the final exponentiation which is usually done differently

